// Drykorn Vertragsmanagement - Prisma Schema
// PostgreSQL 18 mit Full-Text Search

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "fullTextIndex"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== ENUMS ====================

enum ContractStatus {
  DRAFT
  PENDING_APPROVAL
  ACTIVE
  EXPIRED
  TERMINATED
  ARCHIVED
}

enum ContractType {
  SUPPLIER          // Lieferantenvertrag
  CUSTOMER          // Kundenvertrag
  EMPLOYMENT        // Arbeitsvertrag
  LEASE             // Mietvertrag
  LICENSE           // Lizenzvertrag
  NDA               // Geheimhaltungsvereinbarung
  SERVICE           // Dienstleistungsvertrag
  OTHER
}

enum ReminderType {
  EXPIRATION
  RENEWAL
  CUSTOM
}

enum AuditAction {
  CREATE
  READ
  UPDATE
  DELETE
  DOWNLOAD
  EXPORT
}

// ==================== MODELS ====================

enum UserRole {
  ADMIN
  MANAGER
  USER
  VIEWER
}

// UserStatus: Registrierungs-Workflow (permanent)
// - PENDING: Neu registriert, wartet auf Admin-Freigabe
// - ACTIVE: Freigeschaltet durch Admin
// - REJECTED: Abgelehnt durch Admin (Begründung per Email)
enum UserStatus {
  PENDING
  ACTIVE
  REJECTED
}

// User Status Design:
// ┌─────────────────────────────────────────────────────────────────────┐
// │ Login erlaubt wenn: status = ACTIVE UND isActive = true            │
// ├─────────────────────────────────────────────────────────────────────┤
// │ status (UserStatus)  │ Registrierungs-Workflow, permanent          │
// │                      │ PENDING → ACTIVE oder REJECTED durch Admin  │
// ├─────────────────────────────────────────────────────────────────────┤
// │ isActive (Boolean)   │ Temporäre Suspendierung durch Admin         │
// │                      │ User kann später reaktiviert werden         │
// └─────────────────────────────────────────────────────────────────────┘
model User {
  id            String      @id @default(uuid())
  email         String      @unique
  passwordHash  String      @map("password_hash")
  firstName     String      @map("first_name")
  lastName      String      @map("last_name")
  role          UserRole    @default(USER)
  status        UserStatus  @default(PENDING)  // Registrierungs-Status
  department    String?
  isActive      Boolean     @default(true) @map("is_active") // Temporäre Suspendierung
  lastLoginAt   DateTime?   @map("last_login_at")
  createdAt     DateTime    @default(now()) @map("created_at")
  updatedAt     DateTime    @updatedAt @map("updated_at")

  // Security: Login-Versuche und Lockout
  failedLoginAttempts Int       @default(0) @map("failed_login_attempts")
  lockedUntil         DateTime? @map("locked_until")
  lastFailedLoginAt   DateTime? @map("last_failed_login_at")

  // 2FA (optional)
  twoFactorSecret         String?   @map("two_factor_secret")
  twoFactorEnabled        Boolean   @default(false) @map("two_factor_enabled")
  twoFactorFailedAttempts Int       @default(0) @map("two_factor_failed_attempts")
  twoFactorLockedUntil    DateTime? @map("two_factor_locked_until")

  // Relations
  contracts         Contract[]      @relation("ContractOwner")
  createdContracts  Contract[]      @relation("ContractCreator")
  auditLogs         AuditLog[]
  notifications     Notification[]
  deletedDocuments  Document[]      @relation("DocumentDeleter")
  refreshTokens     RefreshToken[]

  @@index([status])
  @@map("users")
}

model RefreshToken {
  id          String    @id @default(uuid())
  token       String    @unique
  userId      String    @map("user_id")
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Device/Session Info
  userAgent   String?   @map("user_agent")
  ipAddress   String?   @map("ip_address")

  expiresAt   DateTime  @map("expires_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  lastUsedAt  DateTime? @map("last_used_at")

  // Revocation
  revokedAt   DateTime? @map("revoked_at")

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model Partner {
  id            String    @id @default(uuid())
  name          String
  type          String    // Lieferant, Kunde, etc.
  address       String?
  contactPerson String?   @map("contact_person")
  email         String?
  phone         String?
  taxId         String?   @map("tax_id")
  notes         String?
  isActive      Boolean   @default(true) @map("is_active")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  // Relations
  contracts     Contract[]

  @@map("partners")
}

model Contract {
  id                  String          @id @default(uuid())
  contractNumber      String          @unique @map("contract_number")
  title               String
  description         String?
  type                ContractType
  status              ContractStatus  @default(DRAFT)

  // Vertragsdaten
  startDate           DateTime?       @map("start_date")
  endDate             DateTime?       @map("end_date")
  terminationDate     DateTime?       @map("termination_date")
  renewalDate         DateTime?       @map("renewal_date")
  noticePeriodDays    Int?            @map("notice_period_days")
  autoRenewal         Boolean         @default(false) @map("auto_renewal")

  // Finanzen
  value               Decimal?        @db.Decimal(15, 2)
  currency            String          @default("EUR")
  paymentTerms        String?         @map("payment_terms")

  // Metadaten
  tags                String[]
  customFields        Json?           @map("custom_fields")

  // Timestamps
  createdAt           DateTime        @default(now()) @map("created_at")
  updatedAt           DateTime        @updatedAt @map("updated_at")

  // Relations
  partnerId           String          @map("partner_id")
  partner             Partner         @relation(fields: [partnerId], references: [id])

  ownerId             String          @map("owner_id")
  owner               User            @relation("ContractOwner", fields: [ownerId], references: [id])

  createdById         String          @map("created_by_id")
  createdBy           User            @relation("ContractCreator", fields: [createdById], references: [id])

  documents           Document[]
  reminders           Reminder[]
  auditLogs           AuditLog[]

  @@index([status])
  @@index([type])
  @@index([endDate])
  @@index([partnerId])
  @@index([contractNumber])
  @@index([title])
  @@index([ownerId])
  @@index([createdById])
  @@map("contracts")
}

model Document {
  id              String    @id @default(uuid())
  filename        String
  originalName    String    @map("original_name")
  mimeType        String    @map("mime_type")
  size            Int
  storagePath     String    @unique @map("storage_path")  // Lokaler Dateipfad
  version         Int       @default(1)
  isMainDocument  Boolean   @default(false) @map("is_main_document")
  checksum        String    // SHA-256 für Integrität

  createdAt       DateTime  @default(now()) @map("created_at")

  // Soft Delete
  deletedAt       DateTime? @map("deleted_at")
  deletedById     String?   @map("deleted_by_id")
  deletedBy       User?     @relation("DocumentDeleter", fields: [deletedById], references: [id])

  // Relations
  contractId      String    @map("contract_id")
  contract        Contract  @relation(fields: [contractId], references: [id], onDelete: Cascade)

  auditLogs       AuditLog[]

  @@index([deletedAt])
  @@map("documents")
}

model Reminder {
  id              String        @id @default(uuid())
  type            ReminderType
  reminderDate    DateTime      @map("reminder_date")
  message         String?
  isSent          Boolean       @default(false) @map("is_sent")
  sentAt          DateTime?     @map("sent_at")

  createdAt       DateTime      @default(now()) @map("created_at")

  // Relations
  contractId      String        @map("contract_id")
  contract        Contract      @relation(fields: [contractId], references: [id], onDelete: Cascade)

  @@index([reminderDate, isSent])
  @@map("reminders")
}

model AuditLog {
  id              String      @id @default(uuid())
  action          AuditAction
  entityType      String      @map("entity_type")
  entityId        String      @map("entity_id")
  oldValue        Json?       @map("old_value")
  newValue        Json?       @map("new_value")
  ipAddress       String?     @map("ip_address")
  userAgent       String?     @map("user_agent")

  createdAt       DateTime    @default(now()) @map("created_at")

  // Relations
  userId          String      @map("user_id")
  user            User        @relation(fields: [userId], references: [id])

  contractId      String?     @map("contract_id")
  contract        Contract?   @relation(fields: [contractId], references: [id], onDelete: SetNull)

  documentId      String?     @map("document_id")
  document        Document?   @relation(fields: [documentId], references: [id], onDelete: SetNull)

  @@index([entityType, entityId])
  @@index([createdAt])
  @@index([userId])
  @@map("audit_logs")
}

model Notification {
  id              String    @id @default(uuid())
  title           String
  message         String
  isRead          Boolean   @default(false) @map("is_read")
  link            String?

  createdAt       DateTime  @default(now()) @map("created_at")
  readAt          DateTime? @map("read_at")

  // Relations
  userId          String    @map("user_id")
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@map("notifications")
}

// Sequence für Vertragsnummern
model ContractSequence {
  id        Int      @id @default(autoincrement())
  year      Int      @unique
  lastValue Int      @default(0) @map("last_value")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("contract_sequences")
}
